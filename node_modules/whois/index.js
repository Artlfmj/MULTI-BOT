#!/usr/bin/env node

// Generated by CoffeeScript 2.5.1
(function() {
  var SocksClient, _, cleanParsingErrors, net, punycode, util, yargs;

  _ = require('underscore');

  net = require('net');

  SocksClient = require('socks').SocksClient;

  punycode = require('punycode');

  util = require('util');

  this.SERVERS = require('./servers.json');

  cleanParsingErrors = (string) => {
    return string.replace(/^[:\s]+/, '').replace(/^https?[:\/]+/, '') || string;
  };

  this.lookup = (addr, options, done) => {
    var _lookup, parts, proxy, server, sockOpts, socket, timeout, tld;
    if (typeof done === 'undefined' && typeof options === 'function') {
      done = options;
      options = {};
    }
    _.defaults(options, {
      follow: 2,
      timeout: 60000 // 60 seconds in ms
    });
    done = _.once(done);
    server = options.server;
    proxy = options.proxy;
    timeout = options.timeout;
    if (!server) {
      switch (true) {
        case _.contains(addr, '@'):
          done(new Error('lookup: email addresses not supported'));
          return;
        case net.isIP(addr) !== 0:
          server = this.SERVERS['_']['ip'];
          break;
        default:
          tld = punycode.toASCII(addr);
          while (true) {
            server = this.SERVERS[tld];
            if (!tld || server) {
              break;
            }
            tld = tld.replace(/^.+?(\.|$)/, '');
          }
      }
    }
    if (!server) {
      done(new Error('lookup: no whois server is known for this kind of object'));
      return;
    }
    if (typeof server === 'string') {
      parts = server.split(':');
      server = {
        host: parts[0],
        port: parts[1]
      };
    }
    if (typeof proxy === 'string') {
      parts = proxy.split(':');
      proxy = {
        ipaddress: parts[0],
        port: parseInt(parts[1])
      };
    }
    _.defaults(server, {
      port: 43,
      query: "$addr\r\n"
    });
    if (proxy) {
      _.defaults(proxy, {
        type: 5
      });
    }
    _lookup = (socket, done) => {
      var data, idn;
      idn = addr;
      if (server.punycode !== false && options.punycode !== false) {
        idn = punycode.toASCII(addr);
      }
      if (options.encoding) {
        socket.setEncoding(options.encoding);
      }
      socket.write(server.query.replace('$addr', idn));
      data = '';
      socket.on('data', (chunk) => {
        return data += chunk;
      });
      socket.on('timeout', () => {
        socket.destroy();
        return done(new Error('lookup: timeout'));
      });
      socket.on('error', (err) => {
        return done(err);
      });
      return socket.on('close', (err) => {
        var match;
        if (options.follow > 0) {
          match = data.replace(/\r/gm, '').match(/(ReferralServer|Registrar Whois|Whois Server|WHOIS Server|Registrar WHOIS Server):[^\S\n]*((?:r?whois|https?):\/\/)?(.*)/);
          if ((match != null) && match[3] !== server.host) {
            options = _.extend({}, options, {
              follow: options.follow - 1,
              server: match[3].trim()
            });
            options.server = cleanParsingErrors(options.server);
            this.lookup(addr, options, (err, parts) => {
              if (err != null) {
                return done(err);
              }
              if (options.verbose) {
                return done(null, [
                  {
                    server: ('object' === typeof server) ? server.host.trim() : server.trim(),
                    data: data
                  }
                ].concat(parts));
              } else {
                return done(null, parts);
              }
            });
            return;
          }
        }
        if (options.verbose) {
          return done(null, [
            {
              server: ('object' === typeof server) ? server.host.trim() : server.trim(),
              data: data
            }
          ]);
        } else {
          return done(null, data);
        }
      });
    };
    if (!Number.isInteger(server.port)) {
      server.port = 43;
    }
    if (proxy) {
      return SocksClient.createConnection({
        proxy: proxy,
        destination: {
          host: server.host,
          port: server.port
        },
        command: 'connect',
        timeout: timeout
      }, (err, {socket}) => {
        if (err != null) {
          return done(err);
        }
        if (timeout) {
          socket.setTimeout(timeout);
        }
        _lookup(socket, done);
        return socket.resume();
      });
    } else {
      sockOpts = {
        host: server.host,
        port: server.port
      };
      if (options.bind) {
        sockOpts.localAddress = options.bind;
      }
      socket = net.connect(sockOpts);
      if (timeout) {
        socket.setTimeout(timeout);
      }
      return _lookup(socket, done);
    }
  };

  if (module === require.main) {
    yargs = require('yargs').usage('$0 [options] address').default('s', null).alias('s', 'server').describe('s', 'whois server').default('f', 0).alias('f', 'follow').describe('f', 'number of times to follow redirects').default('p', null).alias('p', 'proxy').describe('p', 'SOCKS proxy').boolean('v').default('v', false).alias('v', 'verbose').describe('v', 'show verbose results').default('b', null).alias('b', 'bind').describe('b', 'bind to a local IP address').boolean('h').default('h', false).alias('h', 'help').describe('h', 'display this help message');
    if (yargs.argv.h) {
      yargs.showHelp();
      process.exit(0);
    }
    if (yargs.argv._[0] == null) {
      yargs.showHelp();
      process.exit(1);
    }
    this.lookup(yargs.argv._[0], {
      server: yargs.argv.server,
      follow: yargs.argv.follow,
      proxy: yargs.argv.proxy,
      verbose: yargs.argv.verbose,
      bind: yargs.argv.bind
    }, (err, data) => {
      var i, len, part, results;
      if (err != null) {
        console.log(err);
        process.exit(1);
      }
      if (util.isArray(data)) {
        results = [];
        for (i = 0, len = data.length; i < len; i++) {
          part = data[i];
          if ('object' === typeof part.server) {
            console.log(part.server.host);
          } else {
            console.log(part.server);
          }
          console.log(part.data);
          results.push(console.log);
        }
        return results;
      } else {
        return console.log(data);
      }
    });
  }

}).call(this);
